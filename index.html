<!DOCTYPE html>
<html>

<head>
	<meta charset="UTF-8">
	<title>Project 2 Title</title>

	<style>
		/**svg {
			border: solid #ccc 1px;
		}**/

		path.state {
			fill: #ccc;
			stroke: #888;
		}

		.ticks {
  			font: 10px sans-serif;
		}

		.track,
		.track-inset,
		.track-overlay {
  			stroke-linecap: round;
		}

		.track {
		  stroke: #000;
		  stroke-opacity: 0.3;
		  stroke-width: 10px;
		}

		.track-inset {
		  stroke: #ddd;
		  stroke-width: 8px;
		}

		.track-overlay {
		  pointer-events: stroke;
		  stroke-width: 50px;
		  stroke: transparent;
		  cursor: crosshair;
		}

		.handle {
		  fill: #fff;
		  stroke: #000;
		  stroke-opacity: 0.5;
		  stroke-width: 1.25px;
		}

	</style>

	<script src="https://d3js.org/d3.v4.min.js"></script>
	<script src="http://d3js.org/topojson.v2.min.js"></script>
</head>

<body>
	<h1>AirBnB Rooms vs. Hotel Pricings in Major Cities</h1>
	<h2>by Edwin Ma, Michelle Yang, Cynthia Zhu</h2>

	<p id="p1">
	</p>

	<script>
		var width = 900;
		var height = 600;
		var svg1 = d3.select("#p1")
			.append("svg")
			.attr("width", width)
			.attr("height", height);

		var projection = d3.geoAlbersUsa().scale(75);
		var pathGenerator = d3.geoPath().projection(projection);

		var states;
		var Atlas;

		var parseRow = function(row) {
			row.neighbourhood = row.neighbourhood;
			row.latitude = Number(row.latitude);
			row.longitude = Number(row.longitude);
			row.price = Number(row.price);
			row.room_type = row.room_type;
			return row;
		};

		var parseHotel = function(row) {
			row.city = row.city
			row.january = Number(row.january.replace("$", ""));
			return row;
		};

		var Boston;
		var Chicago;
		var DC;
		var LA;
		var NewOrleans;
		var NYC;
		var Portland;
		var SanDiego;
		var Seattle;
		var SF;
		var hotel;

		d3.queue()
			.defer(d3.json, "us_map.json")
			.defer(d3.csv, "listings_Boston.csv", parseRow)
			.defer(d3.csv, "listings_Chicago.csv", parseRow)
			.defer(d3.csv, "listings_DC.csv", parseRow)
			.defer(d3.csv, "listings_LA.csv", parseRow)
			.defer(d3.csv, "listings_NewOrleans.csv", parseRow)
			.defer(d3.csv, "listings_NYC.csv", parseRow)
			.defer(d3.csv, "listings_Portland.csv", parseRow)
			.defer(d3.csv, "listings_SanDiego.csv", parseRow)
			.defer(d3.csv, "listings_Seattle.csv", parseRow)
			.defer(d3.csv, "listings_SF.csv", parseRow)
			.defer(d3.csv, "hotel2016.txt")
			.await(function(error, rawMap, rawBoston, rawChicago, rawDC, rawLA, rawNewOrleans, rawNYC, rawPortland, rawSanDiego, rawSeattle, rawSF, rawHotel) {
				states = topojson.feature(rawMap, rawMap.objects.states);
				// the cities, this is for debugging
				Boston = rawBoston;
				hotel = rawHotel;

				projection.fitExtent([
					[0, 0],
					[svg1.attr("width"), svg1.attr("height")]
				], states);
				pathGenerator = d3.geoPath().projection(projection);

				// draw the map
				var paths = svg1.selectAll("path").data(states.features);
				paths.enter().append("path").attr("class", "state")
					.merge(paths)
					.attr("d", function(state) {
						return pathGenerator(state);
					});

				// scales
				var circleScale = d3.scaleSqrt().domain([0, rawBoston.length]).range([0, 20]);

				// draw the cities
				var cities = {
					Boston: {
						name: "Boston",
						longitude: 71.0589,
						latitude: 42.3601,
						variable: rawBoston
					}
				};

				var circles = svg1.selectAll("circle").data(cities);
				circles.enter().append("circle").merge(circles)
					.attr("cx", function(d) {
						console.log(projection(d)[0]);
						return projection(d)[0];
					})
					.attr("cy", function(d) {
						return projection(d)[1];
					})
					.attr("r", function(d) {
						return circleScale(d.variable.length);
					})
					.style("fill", "red");


				makeSlider();

			});

		/********Slider*********/

		function makeSlider() {

			var margin = {right: 50, left: 50};
			var svg_slider = d3.select('#p1')
			.append("svg")
			.attr("height", 600)
			.attr("width", 500);

			var x = d3.scaleLinear()
    		.domain([0, 180])
    		.range([0, (width / 2) - margin.right])
    		.clamp(true);

    		var slider = svg_slider.append("g")
    		.attr("class", "slider")
    		.attr("transform", "translate(" + margin.left + "," + height / 4 + ")");

    		slider.append("line")
    		.attr("class", "track")
    		.attr("x1", x.range()[0])
    		.attr("x2", x.range()[1])
  			.select(function() { return this.parentNode.appendChild(this.cloneNode(true)); })
    		.attr("class", "track-inset")
  			.select(function() { return this.parentNode.appendChild(this.cloneNode(true)); })
    		.attr("class", "track-overlay")
    		.call(d3.drag()
        	.on("start.interrupt", function() { slider.interrupt(); })
        	.on("start drag", function() { hue(x.invert(d3.event.x)); }));

        	slider.insert("g", ".track-overlay")
    		.attr("class", "ticks")
    		.attr("transform", "translate(0," + 18 + ")")
  			.selectAll("text")
			.data(x.ticks(10))
			.enter().append("text")
			.attr("x", x)
			.attr("text-anchor", "middle")
			.text(function(d) { return d + "Â°"; });

			var handle = slider.insert("circle", ".track-overlay")
    		.attr("class", "handle")
    		.attr("r", 9);

    		slider.transition()
    		.duration(550)
    		.tween("hue", function() {
      		var i = d3.interpolate(0, 70);
      		return function(t) { hue(i(t)); };
    		});

    		function hue(h) {
  				handle.attr("cx", x(h));
  				svg_slider.style("background-color", d3.hsl(h, 0.8, 0.8));
			}
		};


	</script>

</body>

</html>
