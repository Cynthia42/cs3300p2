<!DOCTYPE html>
<html>

<head>
	<meta charset="UTF-8">
	<title>Project 2 Title</title>

	<style>
		div.cityDiv {
			text-align: center;
		}
	</style>


	<script src="https://d3js.org/d3.v4.min.js"></script>
	<script src="http://d3js.org/topojson.v2.min.js"></script>
	<link rel="stylesheet" href="styles.css">

</head>

<body>
	<img id="airbnb" src="airBNB.svg" alt="AirBnB logo" height="43.5px" width="50px" />

	<img id="hotelicon" src="hotel.svg" alt="hotel icon" height="43.5px" width="50px" />


	<h1>AIRBNB vs. HOTELS IN MAJOR U.S. CITIES</h1>
	<h2>by Edwin Ma, Michelle Yang, Cynthia Zhu</h2>
	<div id="cityDiv">
		<p id="cityName">City:</p>
		<p id="cityAvgPrice">Average airBNB Price:</p>
		<p id="cityAvgHotelPrice">Average hotel Price:</p>
		<p id="cityAvgMinNights">Average minimum number of nights:</p>
		<p id="cityAvgAvailableNights">Average available days out of year:</p>
	</div>
	<form id="frequencyOption" action="">
		<input type="radio" value="price" name="frequencyOption" checked> Price<br>
		<input type="radio" value="minimum_nights" name="frequencyOption"> Minimum Nights<br>
		<input type="radio" value="availability_365" name="frequencyOption"> Availability
  	</form>
	<div id="sliders">Nights Available out of Year: <input type="range" id="availabilitySlider" min="200" max="365">
		<p id="availabilityValue"></p><br>Minimum Nights for AirBNB: <input type="range" id="minNightsSlider" min="0" max="8">
		<p id="minNightsValue"></p><br>Price:
		<input type="range" id="priceSlider" min="0" max="200">
		<p id="priceValue"></p>
	</div>


	<p id="p1"></p>

	<script>


		var width = 800;
		var height = 600;

		// svg element for hovering on city
		/*
		var svg0 = d3.select("#p1")
			.append("svg")
			.attr("class", "hoverCity")
			.attr("width", 100)
			.attr("height", 100);*/

		// svg element for map of US
		var svg1 = d3.select("#p1")
			.append("svg")
			.attr("width", width)
			.attr("height", height);

		// svg element that's filled when user clicks on circle (shows detailed city information)

		var svg2 = d3.select("#p1")
			.append("svg")
			.attr("width", width)
			.attr("height", height);

		var USAprojection = d3.geoAlbersUsa().scale(75);
		var pathGenerator = d3.geoPath().projection(USAprojection);

		var states;

		// getting slider values
		var price_slider = document.getElementById("priceSlider");
		var availability_slider = document.getElementById("availabilitySlider");
		var min_nights_slider = document.getElementById("minNightsSlider");

		// show slider values
		document.getElementById("availabilityValue").innerHTML = availability_slider.value;
		document.getElementById("minNightsValue").innerHTML = min_nights_slider.value;
		document.getElementById("priceValue").innerHTML = price_slider.value;


		// for parsing airBNB data
		var parseRow = function(row) {
			//row.neighbourhood = row.neighbourhood;
			row.latitude = Number(row.latitude);
			row.longitude = Number(row.longitude);
			row.price = Number(row.price);
			row.room_type = row.room_type;
			row.minimum_nights = Number(row.minimum_nights);
			row.availability_365 = Number(row.availability_365);
			return row;
		};



		// global variables for debugging
		var Austin;
		var Boston;
		var Chicago;
		var DC;
		var LA;
		var Nashville;
		var NewOrleans;
		var NYC;
		var Portland;
		var SanDiego;
		var Seattle;
		var SF;
		var hotel; // hotel2016.txt data
		var cities; // array of objects

		d3.queue()
			.defer(d3.json, "us_map.json")
			.defer(d3.csv, "listings_Austin.csv", parseRow)
			.defer(d3.csv, "listings_Boston.csv", parseRow)
			.defer(d3.csv, "listings_Chicago.csv", parseRow)
			.defer(d3.csv, "listings_DC.csv", parseRow)
			.defer(d3.csv, "listings_LA.csv", parseRow)
			.defer(d3.csv, "listings_Nashville.csv", parseRow)
			.defer(d3.csv, "listings_NewOrleans.csv", parseRow)
			.defer(d3.csv, "listings_NYC.csv", parseRow)
			.defer(d3.csv, "listings_Portland.csv", parseRow)
			.defer(d3.csv, "listings_SanDiego.csv", parseRow)
			.defer(d3.csv, "listings_Seattle.csv", parseRow)
			.defer(d3.csv, "listings_SF.csv", parseRow)
			.defer(d3.tsv, "hotel2016.txt")
			.await(function(error, rawMap, rawAustin, rawBoston, rawChicago, rawDC, rawLA, rawNashville, rawNewOrleans, rawNYC, rawPortland, rawSanDiego, rawSeattle, rawSF, rawHotel) {
				states = topojson.feature(rawMap, rawMap.objects.states);
				// the cities, this is for debugging
				Austin = rawAustin;
				Boston = rawBoston;

				//hotels = rawHotel;
				// reformat rawHotel

				for (var i = 1; i < rawHotel.length; i++) { // iterate through all rows except first
					//console.log(rawHotel[i]);
					for (var prop in rawHotel[i]) {
						// for each property of the city
						var currentProp = rawHotel[i][prop];
						//console.log("prop:" + currentProp.replace(/_/, " "));
						currentProp = currentProp.replace(/_/, " ");
						rawHotel[i][prop] = rawHotel[i][prop].replace(/\$/, "");
						//console.log(prop);
					}
					// get rid of _ for City
					//city.City = city.City.replace(/_/, " ");
					// get rid of $
					//city.January = city.January.replace(/\$/, "");
					//city.February = city.February.replace(/\$/, "");

				}
				hotels = rawHotel;
				//hotels = rawHotel;


				USAprojection.fitExtent([
					[0, 0],
					[svg1.attr("width"), svg1.attr("height")]
				], states);
				pathGenerator = d3.geoPath().projection(USAprojection);

				// draw the map
				var paths = svg1.selectAll("path").data(states.features);
				paths.enter().append("path").attr("class", "state")
					.merge(paths)
					.attr("d", function(state) {
						return pathGenerator(state);
					});



				// scales
				var circleScale = d3.scaleSqrt().domain([0, rawBoston.length]).range([0, 10]);
				var invertedScale = d3.scaleSqrt().domain([0, 10]).range([0, rawBoston.length]);

				svg1.append("circle").attr("cx", 50).attr("cy", 50).attr("r", 7);
				svg1.append("text").attr("x", 48).attr("y", 52).text("3").style("font-size", 8);

				svg1.append("circle").attr("cx", 50).attr("cy", 50).attr("r", 19.5);
				svg1.append("text").attr("x", 48).attr("y", 42).text("5").style("font-size", 8);

				svg1.append("circle").attr("cx", 50).attr("cy", 50).attr("r", 38);
				svg1.append("text").attr("x", 48).attr("y", 32).text("7").style("font-size", 8);

				svg1.append("text").attr("x", 100).attr("y", 32).text("Number of listings in thousands").style("font-size", 16);

				// draw the scales beneath the sliders
				//svgContainer3.append("g").attr("transform", "translate(0," + String(height - padding) + ")").call(d3.axisBottom(xScale));


				// city info text element
				var cityInfo = svg1.append("text").
				attr("id", "CityInfo").
				//style("text-anchor", "middle").
				style("font-size", "1em").
				style("fill", "blue");

				// cities array
				cities = [{
					name: "Austin",
					longitude: -97.7431,
					latitude: 30.2672,
					variable: rawAustin,
					avgHotelPrice: null
				}, {
					name: "Boston",
					longitude: -71.0589,
					latitude: 42.3601,
					variable: rawBoston
				}, {
					name: "Chicago",
					longitude: -87.6298,
					latitude: 41.8781,
					variable: rawChicago
				}, {
					name: "Washington D.C.",
					longitude: -77.0369,
					latitude: 38.9072,
					variable: rawDC
				}, {
					name: "Los Angeles",
					longitude: -118.2437,
					latitude: 34.0522,
					variable: rawBoston
				}, {
					name: "Nashville",
					longitude: -86.7816,
					latitude: 36.1627,
					variable: rawNashville,
					avgHotelPrice: null
				}, {
					name: "New Orleans",
					longitude: -90.0715,
					latitude: 29.9511,
					variable: rawNewOrleans
				}, {
					name: "New York",
					longitude: -74.0059,
					latitude: 40.7128,
					variable: rawNYC
				}, {
					name: "Portland",
					longitude: -122.6765,
					latitude: 45.5231,
					variable: rawPortland,
					avgHotelPrice: null
				}, {
					name: "San Diego",
					longitude: -117.1611,
					latitude: 32.7157,
					variable: rawSanDiego
				}, {
					name: "Seattle",
					longitude: -122.3321,
					latitude: 47.6062,
					variable: rawSeattle
				}, {
					name: "San Francisco",
					longitude: -122.4194,
					latitude: 37.7749,
					variable: rawSF
				}];

				// for regex purposes
				var re = /room/;

				// adding attributes to cities programmatically
				for (var i = 0; i < cities.length; i++) {
					cities[i].avgPrice = d3.mean(cities[i].variable, function(d) {
						if ((d.room_type).match(re)) {
							return d.price;
						}
					});

					cities[i].avgMinNights = d3.mean(cities[i].variable, function(d) {
						if ((d.room_type).match(re)) {
							return d.minimum_nights;
						}
					});

					cities[i].avgAvailability = d3.mean(cities[i].variable, function(d) {
						if ((d.room_type).match(re)) {
							return d.availability_365;
						}
					});

					// add hotel averages
					for (var j = 0; j < rawHotel.length; j++) {
						if (rawHotel[j].City == cities[i].name) {
							// turn city object into array
							var cityHotelArray = Object.keys(rawHotel[j]).map(function(key) {
								return rawHotel[j][key];
							});

							cities[i].avgHotelPrice = d3.mean(cityHotelArray, function(d) {
								if (d.length == 3) {
									return parseFloat(d);
								}
							})
							//console.log("city:" + rawHotel[j].City);
						}
					}
				}

				var sliderPrice = price_slider.max / 2,
					sliderMinNights = min_nights_slider.max / 2,
					sliderAvailability = (availability_slider.max + availability_slider.min) / 2;

				// getting slider values
				var priceSlider = d3.select("#priceSlider");
				//console.log("priceSlider:" + priceSlider.value);
				priceSlider.on("input", function() {
					sliderPrice = this.value;
					changeCircles(this);
				});

				var minNightsSlider = d3.select("#minNightsSlider");
				minNightsSlider.on("input", function() {
					sliderMinNights = this.value;
					changeCircles(this);
				});

				var availabilitySlider = d3.select("#availabilitySlider");
				availabilitySlider.on("input", function() {
					sliderAvailability = this.value;
					changeCircles(this);
				});

				// handles circles when slider isn't used
				var selectedCities = cities.filter(function(d) {
					return ((d.avgPrice < sliderPrice) && (d.avgMinNights < sliderMinNights) && (d.avgAvailability < sliderAvailability));
				});

				//console.log(selectedCities);
				//console.log(sliderPrice);
				//console.log(sliderMinNights);
				//console.log(sliderAvailability);

				var clickedCities = [];

				selectedCities.forEach(function(city) {
					svg1.append("circle")
						.attr("class", "mapCircles")
						.attr("r", circleScale(city.variable.length))
						.attr("cx", USAprojection([city.longitude, city.latitude])[0])
						.attr("cy", USAprojection([city.longitude, city.latitude])[1])
						.on("mouseover", function() {

							hoverOnCity(city);
						})
						.on("mouseout", function() {
							svg1.selectAll("rect").remove();
							svg1.select("#CityInfo").style("opacity", 0);
							document.getElementById("cityName").innerHTML = "City: ";
							document.getElementById("cityAvgPrice").innerHTML = "Average airBNB Price: ";
							document.getElementById("cityAvgHotelPrice").innerHTML = "Average hotel Price: ";
							document.getElementById("cityAvgMinNights").innerHTML = "Average minimum number of nights: ";
							document.getElementById("cityAvgAvailableNights").innerHTML = "Average available days out of year: ";
						})
						.on("click", function() {
							if (clickedCities.indexOf(city) == -1) {
								// add to array if city doesn't already exist
								clickedCities.push(city);
							} else {
								// remove city from array if it already exists
								clickedCities.splice(clickedCities.indexOf(city), 1);
							}

							//console.log("clicked cities:" + clickedCities);
							showCitiesInfo(clickedCities);
							//var paths = svg1.selectAll("path").data(states.features);

						});


				});

				d3.selectAll('input[name = "frequencyOption"]')
				.on("click", function() {
					showCitiesInfo(clickedCities);
				});
				showCitiesInfo(clickedCities);

				// for hovering on city
				var hoverOnCity = function(city) {
					// if city is to the left of the svg1
					var city_x = USAprojection([city.longitude, city.latitude])[0];
					var city_y = USAprojection([city.longitude, city.latitude])[1];


					var timesGreater = city.avgHotelPrice / city.avgPrice;
					var string = city.name + "'s average hotel price is " + timesGreater.toFixed(2) + " times more expensive than average AirBNB price";

					if (timesGreater == 0) {
						string = "No hotel prices data for " + city.name;
					}

					document.getElementById("cityName").innerHTML += city.name;
					document.getElementById("cityAvgPrice").innerHTML += city.avgPrice;
					document.getElementById("cityAvgHotelPrice").innerHTML += city.avgHotelPrice;
					document.getElementById("cityAvgMinNights").innerHTML += city.avgMinNights;
					document.getElementById("cityAvgAvailableNights").innerHTML += city.avgAvailability;

					if (USAprojection([city.longitude, city.latitude])[0] < width / 2) { // if on left


						svg1.select("#CityInfo").attr("x", city_x + 10)
							.attr("y", city_y - 10)
							.style("text-anchor", "start")
							.text(string).style("opacity", 1);

						//svg0.append("text").attr("x", 50).attr("y", 50).text("test");


					} else { // if city is to the right of the svg1
						if (city.name == "New Orleans") {
							svg1.select("#CityInfo").attr("x", city_x + 80)
								.attr("y", city_y - 10)
								.style("text-anchor", "end")
								.text(string).style("opacity", 1);
						} else {
							svg1.select("#CityInfo").attr("x", city_x + 20)
								.attr("y", city_y - 10)
								.style("text-anchor", "end")
								.text(string).style("opacity", 1);
						}


					}
				}

				/*
				var circles = svg1.selectAll("circle").data(cities);

				circles.enter().append("circle")
					.attr("r", circleScale(city.variable.length))
					.attr("cx", USAprojection([city.longitude, city.latitude])[0])
					.attr("cy", USAprojection([city.longitude, city.latitude])[1])
					.on("mouseover", function() {
						svg1.select("#CityInfo").attr("x", USAprojection([city.longitude, city.latitude])[0] - 15)
							.attr("y", USAprojection([city.longitude, city.latitude])[1] - 50)
							.text(city.name + " # of listings" + city.variable.length + " avg. price" + city.avgPrice);
					}).on("click", function() {
						console.log(city.name);
						var paths = svg1.selectAll("path").data(states.features);
					});

					*/




				// for changing circles
				function changeCircles(sliderData) {
					// remove and add circles depending on slider's value
					//console.log("value: " + sliderData.value); // gives slider's value
					//console.log("id: " + sliderData.id); // gives slider's id
					// values to filter against
					document.getElementById("availabilityValue").innerHTML = availability_slider.value;
					document.getElementById("minNightsValue").innerHTML = min_nights_slider.value;
					document.getElementById("priceValue").innerHTML = price_slider.value;

					//console.log("slider:" + sliderData.value);
					//console.log("price:" + sliderPrice);
					//console.log("nights:" + sliderMinNights);
					//console.log("availability:" + sliderAvailability);
					var selectedCities = cities.filter(function(d) {
						return ((d.avgPrice < sliderPrice) && (d.avgMinNights < sliderMinNights) && (d.avgAvailability < sliderAvailability));
					});

					//console.log(selectedCities);
					svg1.selectAll("circle.mapCircles").remove();

					selectedCities.forEach(function(city) {
						svg1.append("circle")
							.attr("class", "mapCircles")
							.attr("r", circleScale(city.variable.length))
							.attr("cx", USAprojection([city.longitude, city.latitude])[0])
							.attr("cy", USAprojection([city.longitude, city.latitude])[1])
							.on("mouseover", function() {

								hoverOnCity(city);
							})
							.on("mouseout", function() {
								svg1.select("#CityInfo").style("opacity", 0);
								document.getElementById("cityName").innerHTML = "City: ";
								document.getElementById("cityAvgPrice").innerHTML = "Average airBNB Price: ";
								document.getElementById("cityAvgHotelPrice").innerHTML = "Average hotel Price: ";
								document.getElementById("cityAvgMinNights").innerHTML = "Average minimum number of nights: ";
								document.getElementById("cityAvgAvailableNights").innerHTML = "Average available days out of year: ";
							})
							.on("click", function() {
								if (clickedCities.indexOf(city) == -1) {
									// add to array if city doesn't already exist
									clickedCities.push(city);
								} else {
									// remove city from array if it already exists
									clickedCities.splice(clickedCities.indexOf(city), 1);
								}

								showCitiesInfo(clickedCities);
								//var paths = svg1.selectAll("path").data(states.features);

							});

					});

				}

                function showCitiesInfo(cities) {
                    var attrRangesDict = 
                    	{"price": [0,300], 
                    	 "minimum_nights": [0, 30], 
                    	 "availability_365": [0, 365]};
                    var attrFrequencyRangesDict = 
                    	{"price": [0,15], 
                    	 "minimum_nights": [0, 60], 
                    	 "availability_365": [0, 35]};
                    var attrStepSizesDict = 
                    	{"price": 10, 
                    	 "minimum_nights": 1, 
                    	 "availability_365": 5};
                    var attrLabelsDict = 
                    	{"price": "Price Per Night", 
                    	 "minimum_nights": "Minimum Nights of Stay", 
                    	 "availability_365": "Annual Availability"};

                    var attr = document.querySelector('input[name = "frequencyOption"]:checked').value;
                    var attrRange = attrRangesDict[attr];
                    var attrFrequencyRange = attrFrequencyRangesDict[attr];
                    var attrStepSize = attrStepSizesDict[attr];
                    var attrLabel = attrLabelsDict[attr];

                    var cityAttrFrequencyData = 
                    	getCityAttrFrequencyData(cities, attr, attrStepSize, attrRange[1]);
                    console.log(cityAttrFrequencyData);

                    var cityScale = d3.scaleOrdinal(d3.schemeCategory20);
                    var frequencyScale = d3.scaleLinear()
                    .domain(attrFrequencyRange)
                    .range([480, 0]);
                    var frequencyAxis = d3.axisLeft(frequencyScale);
                    
                    var attrScale = d3.scaleLinear()
                    .domain(attrRange)
                    .range([0, 700]);

                    var attrAxis = d3.axisBottom(attrScale);
                    var svg = d3.select("svg:nth-child(2)");
                    svg.selectAll("*").remove();

                    svg.append("text")
                    .attr("id", "CityName")
                    .attr("x", 10)
                    .attr("y", 28)
                    .style("font-size", "18pt");

                    svg.append("text")
                    .attr("id", "CityName")
                    .attr("x", -300)
                    .attr("y", 20)
                    .attr("transform", "rotate(-90)")
                    .text("Percent Frequency")
                    .style("text-anchor", "middle")
                    .style("font-size", "14pt");

                    svg.append("text")
                    .attr("id", "CityName")
                    .attr("x", 400)
                    .attr("y", 580)
                    .text(attrLabel)
                    .style("text-anchor", "middle")
                    .style("font-size", "14pt");

                    var plot = svg.append("g")
                    .attr("transform", "translate(50,50)");

                    plot.append("g")
                    .call(attrAxis)
                    .attr("transform", "translate(0,480)");

                    plot.append("g")
                    .call(frequencyAxis)
                    .attr("transform", "translate(0,0)");
                    
                    var attrPathGenerator = d3.line()
                    .x(function (d) { return attrScale(d[attr])})
                    .y(function (d) { return frequencyScale(d["frequency"])});

                    var paths = plot.selectAll("path.lineGraph").data(cityAttrFrequencyData);
                    paths.enter()
                    .append("path")
                    .merge(paths)
                    .on("mouseover", function (d) {
                        svg.select("#CityName").text(d["city"]);
                    })
                    .attr("class", "lineGraph")
                    .attr("d", function(city) {
                        return attrPathGenerator(city["attrFrequencyData"]);
                    })
                    .attr("style", "fill: none; stroke-width: 2;")
                    .style("stroke", function(city, i) {
                        return cityScale(i);
                    })
                    .transition()
                    .duration(1000);
                }

				function getCityAttrFrequencyData(cities, attr, attrStepSize, attrMax) {
					var cityAttrFrequencyData = [];

					cities.forEach(function(city) {
						var individualCityAttrFrequencyData = 
							{"city": city.name, "attrFrequencyData": []};
						var aggregateFrequency = 0;
						var attrFrequencyDataDict = {};
						city.variable.forEach(function(cityEntry) {
							var cityEntryAttr = cityEntry[attr];
							if (cityEntryAttr != undefined && !isNaN(cityEntryAttr)) {
								if (cityEntryAttr <= attrMax) {
									aggregateFrequency += 1;
									cityEntryAttr = Math.floor(cityEntryAttr/attrStepSize) * attrStepSize;
									if (attrFrequencyDataDict.hasOwnProperty(cityEntryAttr)) {
										attrFrequencyDataDict[cityEntryAttr] += 1;
									} else {
										attrFrequencyDataDict[cityEntryAttr] = 1;
									}	
								}	
							}
						});
						var attrFrequencyDataArray = [];
						for (var key in attrFrequencyDataDict) {
							if (attrFrequencyDataDict.hasOwnProperty(key)) {
								var attrObject = {"frequency": (attrFrequencyDataDict[key]/aggregateFrequency) * 100};
								attrObject[attr] = key;
								attrFrequencyDataArray.push(attrObject);
							}
						}
						individualCityAttrFrequencyData["attrFrequencyData"] = 
							attrFrequencyDataArray;
						cityAttrFrequencyData.push(individualCityAttrFrequencyData)
					});
					return cityAttrFrequencyData;
				}



			});
	</script>

	<div class="credits">Icons made by <a href="http://www.flaticon.com/authors/darius-dan" title="Darius Dan">Darius Dan</a> from <a href="http://www.flaticon.com" title="Flaticon">www.flaticon.com</a> is licensed by
		<a href="http://creativecommons.org/licenses/by/3.0/" title="Creative Commons BY 3.0" target="_blank">CC 3.0 BY</a>
	</div>

	<div class="credits">Icons made by <a href="http://www.flaticon.com/authors/retinaicons" title="Retinaicons">Retinaicons</a> from <a href="http://www.flaticon.com" title="Flaticon">www.flaticon.com</a> is licensed by
		<a href="http://creativecommons.org/licenses/by/3.0/" title="Creative Commons BY 3.0" target="_blank">CC 3.0 BY</a>
	</div>

</body>

</html>


